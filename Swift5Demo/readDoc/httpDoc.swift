//
//  httpDoc.swift
//  Swift5Demo
//
//  Created by 阿永 on 2022/11/7.
//  Copyright © 2022 com.ayong.myapp. All rights reserved.
//

import Foundation

//MARK: - HTTP常见状态码
/*
 
状态码               类别                 原因短语
1xx    Informational（信息性状态码）    接受的请求正在处理
2xx    Success（成功状态码）            请求正常处理完毕
3xx    Redirection（重定向）           需要进行附加操作以完成请求
4xx    Client error（客户端错误）       客户端请求出错，服务器无法处理请求
5xx    Server Error（服务器错误）       服务器处理请求出错
 
 200 OK：表示从客户端发送给服务器的请求被正常处理并返回；
 204 No Content：表示客户端发送给客户端的请求得到了成功处理，
     但在返回的响应报文中不含实体的主体部分（没有资源可以返回）；
 206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，
     响应报文中包含由Content-Range指定范围的实体内容
 
 301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；
 302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；
     301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）
 303 See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源；
     302与303的区别：后者明确表示客户端应当采用GET方式获取资源
 304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、
     If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，
     服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；
 307 Temporary Redirect：临时重定向，与303有着相同的含义，
    307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）
 
 400 Bad Request：表示请求报文中存在语法错误；
 401 Unauthorized：未经许可，需要通过HTTP认证；
 403 Forbidden：服务器拒绝该次访问（访问权限出现问题）
 404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；

 500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；
 503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；
 */

//MARK: - tcp 与 udp
/*
 原理
 TCP、UDP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。
 在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。
 在传输层中有TCP协议与UDP协议。
 在应用层有:TCP包括FTP、HTTP、TELNET、SMTP等协议
 UDP包括DNS、TFTP等协议
 连接->传输数据->关闭连接

 短链接：HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。
       也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。
 长连接：连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。
        长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。

 http的长连接：HTTP也可以建立长连接的，使用Connection:keep-alive，HTTP 1.1默认进行持久连接。
     HTTP1.1和HTTP1.0相比较而言，最大的区别就是增加了持久连接支持
     (貌似最新的 http1.0 可以显示的指定 keep-alive),但还是无状态的，或者说是不可以信任的。

 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。
 每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，
 所以每个操作完后都不断开，二次处理时直接发送数据包就OK了，不用建立TCP连接。
 例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费

 一个TCP连接的“三次握手”
 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），
 同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。
 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，
 此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

 HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，
 要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。
 通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，
 服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。
 若服务器长时间无法收到客户端的请求，则认为客户端“下线”，
 若客户端长时间无法收到服务器的回复，则认为网络已经断开。

 Socket是什么：
 Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。
 在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，
 对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

 套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。
 它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：
 连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。

 应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。
 多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。
 为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。
 应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务

 建立socket连接
 建立Socket连接至少需要一对套接字，
 其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。

 套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
 服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。
 客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。
           为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，
           然后就向服务器端套接字提出连接请求。
 连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求

 创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接

 通信过程
 主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。

 通信链路
 当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。

 与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口，这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接。

 最大动态端口数  MaxUserPort  (Default = 5000, Max = 65534) TCP客户端和服务器连接时，客户端必须分配一个动态端口，默认情况下这个动态端口的分配范围为 1024-5000 ，也就是说默认情况下，客户端最多可以同时发起3977 Socket 连接

 由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网 络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。
 而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。
 很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。
 此时若双方建立的是Socket连接，服务器就可以直接将数 据传送给客户端；
 若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，
 因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。

 UDP
 UDP：用户数据报协议，是一个非连接的协议。
 传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取应用程序的数据，并尽可能的把它扔到网络上。

 1、在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。
 2、由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。
 3、UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。
 4、吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。
 5、UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。
 6、UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。

 TCP与UDP的区别：
 1.基于连接与无连接；
 2.对系统资源的要求（TCP较多，UDP少）；
 3.UDP程序结构较简单；
 4.流模式与数据报模式 ；
 5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证
 */

//MARK: - OSI七层划分
/*
 网络数据传输由下而上共有七层,分别为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层；
 
 各层功能简介
 1、物理层
 物理层位于最低层，它直接面向网络的比特流传输。
 为实现原始比特流的物理传输，必须解决好传输介质、信道类型、数据与信号之间的转换、信号传输中的衰减和噪声等在内的一系列问题。
 另外，物理层标准要给出关于物理接口的机械、电气、功能和规程特性，以便不同的制造厂家能够根据公认的标准各自独立的制造设备，又能相互兼容。
 
 2、数据链路层
 在物理层发送和接收数据的过程中，会出现物理层解决不了的问题。
 涉及相邻节点之间的可靠性数据传输，通过加强物理层传输比特的功能，使之对网路层表现为一条无错的线路。
 在数据传输过程中提供了确认，差错控制和流量控制等机制。
 
 3、网络层
 在通信子网中选择合适的路径。
 使用寻址方案确定哪些网络以及设备在这些网络中所处的位置，不同网络层协议采用的寻址方案不同。
 确定目标节点位置后，负责引导数据包正确的通过网络，找到最优路径，即路由选择。
 提供拥塞控制机制，解决异构网络互联问题。
 
 4、传输层
 负责端到端点间的数据传输和控制功能的层；
 它下面的三层主要面向网络通信，确保信息被准确有效的传输。
 它上面三层则面向用户主机，为用户提供各种服务。
 为会话层提供端到端的可靠数据传输服务。屏蔽了传输层以下的数据通信的细节。会使会话层不受到下三层的技术变化影响。
 
 5、会话层
 两个节点间建立、维护和释放面向用户的连接。
 它是在传输连接的基础上建立的会话连接，并进行数据交换管理，允许数据进行单工、半双工的传送。
 会话层提供了令牌管理和同步两种服务功能。
 
 6、表示层
 关心传输数据的语法和语义。
 涉及处理在两个通信系统间所交换信息的表示方式。包括数据格式变换、数据加密与解密、数据压缩与恢复等功能。
 
 7、应用层
 负责为用户提供网络服务。
 为相互通信的应用程序间或进行之间建立连接、进行同步，建立关于纠错和控制数据完整性过程的协商等，应用层还包含大量的应用协议，
 如分布式数据库访问，文件的交换，电子邮件，虚拟终端等
 
 5、6、7又可归为应用层
 
 http协议 应用层
 tcp udp 传输层
 ip 网络层
 */

//MARK: - socket
/*它是应用层与tcp/ip协议族通信的中间软件抽象层，它是一组接口；
 
 套接字概念socket
 是支持tcp/ip协议的网络通信的基本操作单元，它是网络通信过程中端点的抽象表示。
 包含网络通信的5种信息：连接协议、本地IP、本地进程的协议端口、远端ip、远端进程的协议端口；
 应用层通过传输层进行数据通信时，tcp会遇到同时为多个应用程序进程提供并发服务的问题。
 多个tcp连接或多个应用进程可能需要通过同一个tcp协议端口传输数据。
 为了区别不同的进程和连接，许多计算机操作系统为应用程序与tcp/ip协议交互提供了socket接口。
 应用层和传输层通过socket接口，区分来自不同程序进程或网络通信连接的通信，实现数据传输的并发服务。
 
 socket 连接
 建立socket连接字少需要一对套接字，其中一个运行于客户端，称为clientsocket，另一个运行于服务端，称serverSocket；
 连接过程分为三步：服务器监听，客户端请求，连接确认。
 
 服务器监听：
 服务器端套接字并不定位具体客户端套接字，而是处于等待连接状态，实时监控网络状态，等待客户端的连接请求。
 
 客户端请求：
 指客户端的套接字提出连接请求，要连接服务器端的套接字。
 客户端的套接字首先要描述它要连接的服务器的套接字，指出服务端的套接字的地址和端口号，然后向服务端的套接字提出请求。
 
 连接确认：
 当服务端收到客户端的连接请求时，就响应客户端的套接字请求，建立一个新的线程，把服务端的套接字描述发送给客户端，一旦客户端确认，双发就建立了连接
 
 */

//MARK: - TCP的三次握手
/*
 指建立tcp连接时，客户端和服务器总共需要发送3个包。
 目的是：连接服务器指定端口，建立tcp连接，并同步连接双方的序列号和确认号并交换tcp窗口大小信息。
 
 syn同步标志 ack确认标志 seq序列号
 1、客户端发送 syn报文: syn=1 seq=x             到服务器
 2、服务器发送 syn+ack报文: syn=1 ack=x+1 seq=y 到客户端
 3、客户端发送 ack报文: ack=y+1 seq=z           到服务器
 */

//MARK: - TCP的四次挥手
/*
 客户端和服务端均可发起挥手
 1、主动方 发送 fin+ack报文：fin=1 ack=z seq=x  被动方 确认
 2、被动方 发送 ack报文： ack=x+1 seq=z         主动方
 3、被动方 发送 fin+ack报文：fin=1 ack=x seq=y  主动方
 4、主动方 发送 ack报文： ack=y seq=x           被动方
 */

//MARK: - HTTP post的body体使用form-urlencoded和multipart/form-data的区别
/*
 1、application/x-www-form-urlencoded：
 窗体数据被编码为名称/值对，这是标准且默认的编码格式。
 当action为get时候，客户端把form数据转换成一个字串append到url后面，用?分割。
 当action为post时候，浏览器把form数据封装到http body中，然后发送到server

 multipart/form-data：
 multipart表示的意思是单个消息头包含多个消息体的解决方案。
 multipart媒体类型对发送非文本的各媒体类型是有用的。
 一般多用于文件上传。
 multipart/form-data只是multipart的一种。
 */

//MARK: - GET和POST的区别
/*
 HTTP超文本传输协议，是短连接，是客户端主动发送请求，服务器做出响应，服务器响应之后，链接断开。
 HTTP是一个属于应用层面向对象的协议.
 HTTP有两类报文：请求报文和响应报文。

 HTTP请求报文：一个HTTP请求报文由请求行、请求头部、空行和请求数据4部分组成。
 HTTP响应报文：由三部分组成：状态行、消息报头、响应正文

 GET请求：
 参数在地址后拼接
 没有请求数据
 不安全（因为所有参数都拼接在地址后面）
 不适合传输大量数据（长度有限制，为1024个字节)
 
 POST请求：
 参数在请求数据区放着，把提交的数据放置在HTTP包的包体<request-body>中
 相对GET请求更安全，
 数据大小没有限制。
 */

//MARK: - HTTPS的加密原理
/*
 服务器端用非对称加密(RSA)生成公钥和私钥
 然后把公钥发给客户端, 服务器则保存私钥
 客户端拿到公钥后, 会生成一个密钥, 这个密钥就是将来客户端和服务器用来通信的钥匙
 然后客户端用公钥对密钥进行加密, 再发给服务器
 服务器拿到客户端发来的加密后的密钥后, 再使用私钥解密密钥, 到此双方都获得通信的钥匙
 */

